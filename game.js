import { Input } from './engine/input.js'; import { Assets } from './engine/assets.js'; import { TileMap } from './engine/map.js'; import { Entity } from './engine/entity.js'; import { NPC } from './engine/npc.js'; import { QuestManager } from './engine/quest.js'; import { MiniGames } from './engine/minigames.js'; const canvas = document.getElementById('game'); const ctx = canvas.getContext('2d'); const dialogEl = document.getElementById('dialog'); const dialogTextEl = document.getElementById('dialog-text'); const dialogNextBtn = document.getElementById('dialog-next'); const questLogEl = document.getElementById('quest-log'); const miniGameOverlay = document.getElementById('mini-game-overlay'); const miniGameCanvas = document.getElementById('mini-game-canvas'); const miniGameExitBtn = document.getElementById('mini-game-exit'); const input = new Input(); const assets = new Assets(); const quests = new QuestManager(); const miniGames = new MiniGames(); const camera = {x:0,y:0,w:canvas.width,h:canvas.height}; let player; let map; let npcs = []; let activeNPC = null; let inDialog = false; const TILE_SIZE=16; const MAP_W=60; const MAP_H=40; function generateMap(){ const tiles = new Array(MAP_W*MAP_H).fill(0); for(let r=0;r<MAP_H;r++){ for(let c=0;c<MAP_W;c++){ const idx=r*MAP_W+c; if(r===0||c===0||r===MAP_H-1||c===MAP_W-1){ tiles[idx]=2; } else { tiles[idx]=1; } } } for(let i=0;i<120;i++){ const rx = 2+Math.floor(Math.random()*(MAP_W-4)); const ry = 2+Math.floor(Math.random()*(MAP_H-4)); tiles[ry*MAP_W+rx] = 2; } return new TileMap({ width:MAP_W, height:MAP_H, tileSize:TILE_SIZE, tiles, collisionTiles:[2] }); } async function init(){ map = generateMap(); player = new Entity({x: TILES(5), y: TILES(5), w:16, h:16, speed:70}); player.type='player'; const npc = new NPC({ x: TILES(10), y: TILES(8), w:16,h:16, dialog:[ "Welcome to the island!", "Collect 3 glowing shells scattered around.", "Return to me once you have them." ], onInteract: ()=> { if(shellCount>=3){ quests.progress('shells'); return ["Great job! Quest complete."]; } return null; } }); npcs.push(npc); quests.addQuest('shells','Gather Shells',1); spawnShells(3); loop(0); } function TILES(n){ return n*TILE_SIZE; } let shells=[]; let shellCount=0; function spawnShells(n){ shells=[]; for(let i=0;i<n;i++){ shells.push({ x: TILES(6 + i*3), y: TILES(12 + (i%2)*2), w:12, h:12, collected:false }); } } function updatePlayer(dt){ if(inDialog) return; let vx=0, vy=0; if(input.down('arrowup')||input.down('w')) vy -=1; if(input.down('arrowdown')||input.down('s')) vy +=1; if(input.down('arrowleft')||input.down('a')) vx -=1; if(input.down('arrowright')||input.down('d')) vx +=1; const len = Math.hypot(vx,vy)||1; vx/=len; vy/=len; player.vx = vx*player.speed; player.vy = vy*player.speed; if(Math.abs(vx)>Math.abs(vy)){ player.facing = vx>0?'right':'left'; } else if(Math.abs(vy)>0){ player.facing = vy>0?'down':'up'; } const nx = player.x + player.vx*dt; if(!map.isBlocked(nx, player.y, player.w, player.h)) player.x=nx; const ny = player.y + player.vy*dt; if(!map.isBlocked(player.x, ny, player.w, player.h)) player.y=ny; player.animate(dt, 4); } function checkInteraction(){ if(input.consume(' ') && !inDialog){ for(const n of npcs){ const dist = Math.hypot((n.x - player.x),(n.y - player.y)); if(dist < 40){ startDialog(n); break; } } } } function startDialog(npc){ activeNPC=npc; inDialog=true; dialogEl.classList.remove('hidden'); dialogTextEl.textContent=npc.getCurrentLine(); } dialogNextBtn.addEventListener('click', ()=>{ if(!activeNPC) return; if(activeNPC.dialogIndex === activeNPC.dialog.length-1){ const alt = activeNPC.onInteract?.(); if(Array.isArray(alt)){ activeNPC.dialog = alt; activeNPC.dialogIndex=0; dialogTextEl.textContent=activeNPC.getCurrentLine(); return; } } const cont = activeNPC.advanceDialog(); if(!cont){ inDialog=false; activeNPC=null; dialogEl.classList.add('hidden'); } else { dialogTextEl.textContent=activeNPC.getCurrentLine(); } }); miniGameExitBtn.addEventListener('click', ()=>{ miniGames.exit(); miniGameOverlay.classList.add('hidden'); }); function maybeEnterMiniGame(){ if(input.consume('m') && !inDialog){ miniGameOverlay.classList.remove('hidden'); miniGames.start('reaction', miniGameCanvas); } } function collectShells(){ for(const sh of shells){ if(sh.collected) continue; const dx = (player.x+player.w/2) - (sh.x+sh.w/2); const dy = (player.y+player.h/2) - (sh.y+sh.h/2); if(Math.hypot(dx,dy) < 18){ sh.collected=true; shellCount++; if(shellCount>=3){ quests.progress('shells'); } } } } function update(dt){ updatePlayer(dt); for(const n of npcs) n.update(dt,map); checkInteraction(); maybeEnterMiniGame(); collectShells(); miniGames.update(dt); camera.x = player.x - camera.w/2 + player.w/2; camera.y = player.y - camera.h/2 + player.h/2; camera.x = Math.max(0, Math.min(camera.x, map.width*TILE_SIZE - camera.w)); camera.y = Math.max(0, Math.min(camera.y, map.height*TILE_SIZE - camera.h)); questLogEl.textContent=quests.renderText(); } function draw(){ ctx.imageSmoothingEnabled=false; ctx.clearRect(0,0,canvas.width,canvas.height); const tilesImg = assets.getImage('tiles'); if(tilesImg) map.draw(ctx, tilesImg, camera); for(const sh of shells){ if(sh.collected) continue; ctx.fillStyle='#ffcc33'; ctx.fillRect(Math.floor(sh.x - camera.x), Math.floor(sh.y - camera.y), sh.w, sh.h); } for(const n of npcs){ n.draw(ctx, camera, assets.getImage('npc1'), 4); } player.draw(ctx, camera, assets.getImage('hero'), 4); for(const n of npcs){ const dist = Math.hypot(n.x-player.x, n.y-player.y); if(dist<40 && !inDialog){ ctx.fillStyle='rgba(255,255,255,0.8)'; ctx.fillRect(Math.floor(n.x - camera.x)+2, Math.floor(n.y - camera.y)-10, 12,8); ctx.fillStyle='#000'; ctx.font='6px monospace'; ctx.fillText('E', Math.floor(n.x - camera.x)+5, Math.floor(n.y - camera.y)-4); } } miniGames.draw(); } let last=0; function loop(ts){ const dt = Math.min(0.033, (ts - last)/1000); last=ts; update(dt); draw(); requestAnimationFrame(loop); } async function start(){ await assets.loadAll([ {name:'tiles', src:'assets/tileset.png'}, {name:'hero', src:'assets/hero.png'}, {name:'npc1', src:'assets/npc1.png'} ]); init(); } start();