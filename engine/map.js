export class TileMap { constructor({width,height,tileSize,tiles,collisionTiles}){ this.width=width; this.height=height; this.tileSize=tileSize; this.tiles=tiles; this.collisionTiles = new Set(collisionTiles || []); } draw(ctx, tilesetImage, camera){ const {tileSize} = this; const startCol = Math.floor(camera.x / tileSize); const startRow = Math.floor(camera.y / tileSize); const endCol = startCol + Math.ceil(camera.w / tileSize)+1; const endRow = startRow + Math.ceil(camera.h / tileSize)+1; for(let row=startRow; row<endRow; row++){ if(row<0||row>=this.height) continue; for(let col=startCol; col<endCol; col++){ if(col<0||col>=this.width) continue; const idx = row*this.width + col; const t = this.tiles[idx]; if(t===0) continue; ctx.drawImage( tilesetImage, (t-1)*tileSize, 0, tileSize, tileSize, Math.floor(col*tileSize - camera.x), Math.floor(row*tileSize - camera.y), tileSize, tileSize ); } } } isBlocked(px,py,w,h){ const {tileSize} = this; const points = [ [px,py],[px+w-1,py],[px,py+h-1],[px+w-1,py+h-1] ]; for(const [x,y] of points){ const col = Math.floor(x / tileSize); const row = Math.floor(y / tileSize); if(row<0||row>=this.height||col<0||col>=this.width) return true; const t = this.tiles[row*this.width+col]; if(this.collisionTiles.has(t)) return true; } return false; } }